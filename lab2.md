#### Lab2报告

阅读老师提供的v9-cpu文件夹中包含的os2.c代码，分析lab2.c的设计实现过程如下：

主函数首先将内核态的栈指针设到内存中4MB的位置，然后调用函数*setup_paging()*进行页表的建立。

在*setup_paging()*函数中，首先定义一个大小为6*4K字节的数组pg_mem，从而为分配1个页目录表，和4个页做准备（多出来的4K字节是便于地址以4K为单位对齐）。

接着，将pg_mem的起始地址以4K为宽度对齐后的地址，赋给pg_dir指针。
通过PDIR指令将pg_dir的地址设置为页目录表的起始地址，并通过SPAG指令设置页机制使能。页目录表的大小是1024（即最多存储1024个页表项），每个页的大小为4KB。函数中，紧邻着4KB大小的页目录表的末尾，连续分配了4个页pg0，pg1，pg2，pg3，并将这4个页的内存初始化成一系列连续增长的整数值。同时4个页的内存中每一个地址，都设置了PTE_P，PTE_W，PTE_U三个标志位，表示pg0-pg4这四个页的地址存放在了页目录表中的前四项中，页目录表的其余表项均置0。至此页表设置完成。

os2.c还对对内存读、写时触发页错误进行了实验测试。读和写的地址均为50<<12 = 51200 = 0x00032000，对应的物理地址是pg1的第50帧，分别触发了错误码为FWPAGE和FRPAGE的中断。这是因为之前的代码中将pg0[50]置0，也就是PTE_P和PTE_W标志位均被置了0。PTE_P置0时，页表项对应的页既不可读又不可写；当PTE_P置1且PTE_W置0时，页表项对应的页可读但不可写；当PTE_P置1且PTE_W置1时，页表项对应的页可读且可写。





